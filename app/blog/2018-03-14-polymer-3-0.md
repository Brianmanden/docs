---
title:  "Hands-on with the latest Polymer 3.0 preview"
---

In a previous [blog post on paths and names](2018-02-26-3.0-preview-paths-and-names), we announced some changes to the way we handle module imports in Polymer 3.0, and described why we made those changes. We're happy to announce that you can try out the new import syntax in the latest Polymer 3.0 preview!

* [Simpler module imports](#packagenames)
* [Import the renamed base Polymer element class, PolymerElement](#renamed)
* [Dynamic imports](#dynamicimports)
* [Tools](#tools)
* [What next?](#whatnext)
* [Sample app and element with the new preview](#samples)

## Simpler module imports {#packagenames}

In this release, we add support for importing modules using their package names. From now on, we recommend using package names instead of full paths in the import statements in your Polymer apps and elements.

For example, instead of referring to the Polymer library by its full path, as we did in previous Polymer 3.0 releases:

Old import syntax { .caption }

```js
import { Element as PolymerElement } from './node_modules/@polymer/polymer/polymer-element.js';
```

From this release onwards, you can refer to the Polymer library using its package name.

New import syntax { .caption }

```js
import { PolymerElement } from '@polymer/polymer/polymer-element.js';
```

Using package names in your imports makes it easier to move your project's dependencies around, and means that apps and reusable elements can use the same import statements. Previously, for example, you had to import the Polymer library from `./node_modules/@polymer/polymer/polymer-element.js` in apps, and from `../@polymer/polymer/polymer-element.js` in reusable elements. Now, apps and reusable elements can both import from `@polymer/polymer/polymer-element.js`.

At present, web browsers need the full path to an import to process it. A discussion on supporting imports by package name in browsers is ongoing-for example, see this [proposal for pacakge name maps](https://github.com/domenic/package-name-maps). 

For now, the Polymer CLI tools automatically resolve and rewrite imports that use package names to imports that use paths, producing web-compatible code for the browser.

### What you need to do

* If you're converting a Polymer 2.x project, you don't need to do anything. The Polymer Modulizer will handle it for you. 

* Continue to use paths to import modules that are parts of your app. For example:
	 
  ```js
  // this syntax won't change
  import './my-view.js'
  ```

* If you're updating code that you wrote with a previous Polymer 3.0 preview,
  we recommend you change any imports of npm packages to use package names, 
  like in [the examples below](#examples).

* If you're writing new Polymer 3.0 code, we recommend you import npm packages
  using their package names, like in [the examples below](#examples). 

* When serving unbuilt code that imports package names with the Polymer CLI
  development server (`polymer serve`), be sure to run the server with the
  `--npm` and `--module-resolution=node` options set. You can set these options
  from command line flags, or from `polymer.json`. See the section of this post on [Tools](#tools) for detailed instructions. 

* When building your apps and elements, TODO 

### Potential questions and answers

**Can I still use paths to import my dependencies?**

Yes. Valid paths, which start with `/`, `./`, or `../` won't be transformed by the Polymer CLI tools.

**What happens if I mix paths and package names?**

Your code will work as normal. Valid paths, which start with `/`, `./`, or `../` won't be transformed by the Polymer CLI tools.

**Which tools have been updated to handle imports that use package names?**

All of the Polymer CLI tools have been updated with this functionality. The Polymer CLI development server (`polymer serve`) resolves package names to paths, and rewrites them on-the-fly. The Polymer CLI build toolset (`polymer build`, `polymer-analyzer`, `polymer-bundler`, etc) handles these transformations as well. `polymer build` outputs web-compatible code by default. TODO - is this true?

See the [Polymer CLI changelog](https://github.com/Polymer/polymer-cli/blob/master/CHANGELOG.md) for full details of the changes.

### Use the new import syntax {#examples}

To import the Polymer library:
```js
import { PolymerElement } from '@polymer/polymer/polymer-element.js';
```

To import a helper element from the Polymer library:
```js
import '@polymer/polymer/lib/elements/dom-if.js';
```

To import a Polymer Element:
```js
import '@polymer/paper-checkbox/paper-checkbox.js';
```

To import a behavior:
```js
import {IronResizableBehavior}
    from '@polymer/iron-resizable-behavior/iron-resizable-behavior.js';
```

To import utility modules like `Async` that export several members, you can import individual members, or import the entire module:
```js
import * as Async from '@polymer/polymer/lib/utils/async.js'
Async.microTask.run(callback);
```

The Polymer 3.0 API docs are still in progress-so for the moment, refer to a module's source code to determine what it exports.

### Code samples

#### Old Polymer 3.0 preview syntax

```js
/* my-app.js
 * 
 * Old syntax used full path names.
 * Also, the main export of polymer-element.js
 * was called Element and had to be renamed on import. 
 */
import { Element as PolymerElement } from './node_modules/@polymer/polymer/polymer-element.js';
import './node_modules/@polymer/polymer/lib/elements/dom-if.js';
import './node_modules/@polymer/paper-checkbox/paper-checkbox.js';
import './my-view.js';

class MyApp extends PolymerElement {
  static get template () {
    // Old syntax let you return a string literal.
    return `
      <h1>Hello World</h1>
      <template is="dom-if" if="true">
        <paper-checkbox>I like pie</paper-checkbox>
      </template>
      <my-view></my-view>
    `;
  }
}
customElements.define('my-app', MyApp);
```

```html
<!-- index.html -->
<!-- this doesn't change -->
<!-- polyfills, metadata, etc -->
<script type="module" src="./my-app.js">
<my-app></my-app>
```

#### Current Polymer 3.0 preview syntax

```js
/* 
 * my-app.js
 * 3 changes:
 * - Import statements now use package names instead of full paths
 * - polymer-element.js exports PolymerElement instead of Element, no 
 *   need to rename it
 * - Import the html helper function from polymer-element.js for templates
*/
import { PolymerElement, html } from '@polymer/polymer/polymer-element';
import '@polymer/polymer/lib/elements/dom-if';
import '@polymer/paper-checkbox/paper-checkbox';
// continue to use paths for importing other modules that are part of your app
import './my-view.js';

class MyApp extends PolymerElement {
  static get template (){
    // Always return an HTMLTemplateElement, not a string literal
    return html`
      <h1>Hello World</h1>
      <template is="dom-if" if="true">
        <paper-checkbox>I like pie</paper-checkbox>
      </template>
      <my-view></my-view>
    `;
  }
} 
customElements.define('my-app', MyApp);
```

```html
<!-- index.html -->
<!-- this doesn't change -->
<!-- polyfills, metadata, etc -->
<script type="module" src="./my-app.js">
<my-app></my-app>
```

## Renamed exports {#renamed}
Previously, it was necessary to change the symbol for the main export of `@polymer/polymer/polymer-element.js` from `Element` to some other symbol on import. This export has been renamed to `PolymerElement`. You can now use this symbol without changing it: 

```js
import { PolymerElement, html } from '@polymer/polymer/polymer-element.js';

class MyApp extends PolymerElement {
  //...
}
customElements.define('my-app', MyApp);
```

## Dynamic imports {#dynamicimports}
The latest versions of Chrome and Safari support dynamic imports using the `import()` operator (a polyfill is still to come).

The import operator acts like a function, and returns a `Promise`:

```js
import('my-view1.js').then((MyView1) => {
  console.log("MyView1 loaded");
}).catch((reason) => {
  console.log("MyView1 failed to load", reason);
});
```

Dynamic imports enable lazy-loading of resources, replacing the functionality that we previously used for this in Polymer 2.0 (`importHref()`). 

## Tools {#tools}

We have made changes to the Polymer CLI tools to support imports using package names.

### Polymer CLI development server

When serving unbuilt code that uses package names with the Polymer CLI development server (`polymer serve`), be sure to run the server with the `--npm` and `--module-resolution=node` flags set. You can set these options from command line flags, or from `polymer.json`. 
	
To set the options from command line flags, run the following command from your root project folder: 

```
polymer serve --npm --module-resolution=node
```

To set the options from your polymer.json file:

polymer.json
```json
{ 
  //...
  "npm": true,
  "moduleResolution": "node",
  //...
}
```

`polymer serve` will use the options you define in `polymer.json`.

For more information, see the [documentation on the Polymer CLI commands](/{{{polymer_version_dir}}}/docs/tools/polymer-cli-commands) and [the polymer.json spec](/{{{polymer_version_dir}}}/docs/tools/polymer-json).

### Changes to defaults

TODO: Have any defaults been changed?

### New polymer.json properties

* `root`: Optional string. Defaults to the current working folder.
  
  The path to the root project folder. This can be an absolute path, or a path relative
  to the current working folder. 

  ```json
  "root": "/full/path/to/myfolder"
  ```
  
  ```json
  "root": "a/relative/path"
  ```

* `moduleResolution`: Optional string. Defaults to `"none"`.

  Specifies how the Polymer CLI tools will resolve package names.

  To disable module specifier rewriting: 

  ```json
  "moduleResolution": "none"
  ```

  To use Node.js resolution to find modules: 

  ```json
  "moduleResolution": "node"
  ```

* `componentDir`: Optional string. Defaults to `"node_modules"`. 

  Specifies the folder containing this project's components. 

  ```json
  "componentDir": "path/to/components"
  ```

TODO: check this for new/changed options https://github.com/Polymer/polymer-project-config/blob/master/src/index.ts

TODO: check this for new/changed options https://github.com/Polymer/polymer-project-config/blob/master/src/builds.ts

TODO: edit and publish this, or make info avail? https://github.com/Polymer/docs/pull/2498 

## What next?

With this preview, the core library is feature complete, marking another step on the road to a stable Polymer 3.0 release.

The following are still to come:

* A complete set of developer and API docs for Polymer 3.0
* The finishing touches for the Polymer 3.0 elements
* Tools features: TODO 
* Template Polymer 3.0 apps and elements for `polymer init`
